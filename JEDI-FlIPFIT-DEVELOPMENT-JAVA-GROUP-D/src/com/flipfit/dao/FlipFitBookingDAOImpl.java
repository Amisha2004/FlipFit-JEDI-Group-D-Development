package com.flipfit.dao;

import com.flipfit.bean.*;
import com.flipfit.constants.DBConstants;
import com.flipfit.exceptions.*;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class FlipFitBookingDAOImpl implements FlipFitBookingDAOInterface{
    /**
     * makeBooking
     * @param booking
     * @return
     */
    @Override
    public FlipFitBooking makeBooking(FlipFitBooking booking) {
        Connection conn = null;
        try {
            conn = GetConnection.getConnection();
            // Start the transaction
            conn.setAutoCommit(false);

            // --- Step 1: Update the Slot in slotstable to decrease seatsAvailable by 1 ---
            String updateSlotSql = "UPDATE Slots SET seatsAvailable = seatsAvailable - 1 WHERE slotId = ? AND seatsAvailable > 0";
            try (PreparedStatement updateStmt = conn.prepareStatement(updateSlotSql)) {
                updateStmt.setInt(1, booking.getSlotId());
                int rowsAffected = updateStmt.executeUpdate();
                if (rowsAffected == 0) {
                    // This means the slot was already full or didn't exist. Fail the transaction.
                    throw new SQLException("Update slot failed");
                }
            }

            // --- Step 2: Insert the new booking record ---
            // We do not insert bookingId as it is auto-generated by the database.
            String insertBookingSql = "INSERT INTO Booking (bookingId, userId, slotId) VALUES (?, ?, ?)";
            try (PreparedStatement stmt = conn.prepareStatement(insertBookingSql, Statement.RETURN_GENERATED_KEYS)) {
                stmt.setInt(1, booking.getBookingId());
                stmt.setInt(2, booking.getUserId());
                stmt.setInt(3, booking.getSlotId());

                int affectedRows = stmt.executeUpdate();
                if (affectedRows == 0) {
                    throw new SQLException("Creating booking failed, no rows affected.");
                }

                // Retrieve the auto-generated bookingId
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        int bookingID = generatedKeys.getInt(1);
                        booking.setBookingId(bookingID); // Set the new ID back into the object
                    } else {
                        throw new SQLException("Creating booking failed, no ID obtained.");
                    }
                }
            }

            // If both operations succeed, commit the transaction.
            conn.commit();

        } catch (Exception e) {
            System.out.println(e.getMessage());
            try {
                if (conn != null) conn.rollback();
            } catch (SQLException ex) {
                System.err.println("Error during transaction rollback: " + ex.getMessage());
            }
        } finally {
            try {
                if (conn != null) {
                    conn.setAutoCommit(true);
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        return booking;
    }


    /**
     * Cancels a booking and increments the corresponding slot's availability.
     * This is performed as a single atomic transaction.
     *
     * @param bookingId The ID of the booking to cancel.
     * @param slotId    The ID of the slot to be restocked.
     * @return true if the cancellation was successful, false otherwise.
     */
    @Override
    public boolean deleteBooking(int bookingId, int slotId) {
        Connection conn = null;
        try {
            conn = GetConnection.getConnection();
            // Start the transaction
            conn.setAutoCommit(false);

            // --- Step 1: Delete the booking from the Booking table ---
            String deleteBookingSql = "DELETE FROM Booking WHERE bookingId = ?";
            try (PreparedStatement deleteStmt = conn.prepareStatement(deleteBookingSql)) {
                deleteStmt.setInt(1, bookingId);
                int i = deleteStmt.executeUpdate();
                if (i == 0) {
                    // This means the bookingId was not found.
                    throw new SQLException("Cancellation failed. Booking ID not found.");
                }
            }

            // --- Step 2: Increment the seats available in the Slots table ---
            String updateSlotSql = "UPDATE Slots SET seatsAvailable = seatsAvailable + 1 WHERE slotId = ?";
            try (PreparedStatement updateStmt = conn.prepareStatement(updateSlotSql)) {
                updateStmt.setInt(1, slotId);
                updateStmt.executeUpdate();
            }

            // If both operations succeed, commit the transaction.
            conn.commit();
            System.out.println("Booking " + bookingId + " cancelled and slot availability updated.");
            return true;

        } catch (SQLException e) {
            System.err.println("Transaction failed for cancellation: " + e.getMessage());
            try {
                if (conn != null) conn.rollback();
            } catch (SQLException ex) {
                System.err.println("Error during transaction rollback: " + ex.getMessage());
            }
            return false;

        } finally {
            try {
                if (conn != null) {
                    conn.setAutoCommit(true);
                    conn.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * getAllBookings
     * @param userId
     * @return
     */
    @Override
    public List<FlipFitBooking> getAllBookings(int userId){
        List<FlipFitBooking> bookings = new ArrayList<>(); // Initialize the list to an empty list

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection con = DriverManager.getConnection(
                    DBConstants.DB_URL, DBConstants.USER, DBConstants.PASSWORD);

            PreparedStatement stmt = con.prepareStatement("SELECT * FROM Booking WHERE userId = ?");
            stmt.setInt(1, userId);

            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                int UserId = rs.getInt("userId");
                int slotId = rs.getInt("slotId");
                int bookingId = rs.getInt("bookingId");

                FlipFitBooking booking = new FlipFitBooking();
                booking.setUserId(UserId);
                booking.setSlotId(slotId);
                booking.setBookingId(bookingId);

                bookings.add(booking);
            }

            con.close();
        } catch (SQLException e) {
            System.out.println("Error getting all bookings: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        return bookings;
    }

    /**
     * getBookingDetails
     * @param bookingId
     * @return
     */
    @Override
    public FlipFitBooking getBookingDetailsByBookingId(int bookingId){
        FlipFitBooking bookings = new FlipFitBooking();
        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection con = DriverManager.getConnection(
                    DBConstants.DB_URL, DBConstants.USER, DBConstants.PASSWORD);

            PreparedStatement stmt = con.prepareStatement("SELECT * FROM Booking WHERE bookingId = ?");
            stmt.setInt(1, bookingId);

            ResultSet rs = stmt.executeQuery();

            while (rs.next()) {
                int UserId = rs.getInt("userId");
                int SlotId = rs.getInt("slotId");

                FlipFitBooking booking = new FlipFitBooking();
                booking.setUserId(UserId);
                booking.setSlotId(SlotId);

                bookings = booking;
            }
            rs.close();
            stmt.close();
            con.close();
        } catch (SQLException e) {
            System.out.println("Error getting booking details: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        return bookings;
    }
}
